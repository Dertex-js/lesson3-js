// Функция - это объект, который позволяет вынести некоторую логику
// Функции могут принимать аргументы и возвращать значения
// Параметры в функцию передаются по значению, если это значения примитивны типов, и по ссылке, если это объекты
// Если подразумевается неограниченное количество аргументов, можно  обратиться с помощью spread/rest оператора
// Если у функции явно не прописано, какое значение она возвращает, то такая функция возвращает undefined

// Объявления функций могут быть:
// Function Declaration. Такие функции создаются до выполнения кода и могут быть вызваны до объявления.
foo() // Никакой ошибки, функция вызвана до ее объявления
function foo() {
  //code
}

// Function Expression Такие функции до объявления вызвать нелья.
// bar() // Переменная не была инициализирована
const bar = function() {
  //code
}
bar() // А вот тут все нормально

// Контекст
// Контекст - это область, где вызывается ваш код

// В этой функции this ограничивается обкектом, в котором он используется
const person = {
  name: "Rachel",
  surname: "Green",
  sayHello: function () {
    console.log(`Hello, I'm ${this.name} ${this.surname}`)
  }
}
person.sayHello()
// setTimeout(person.sayHello, 100)

// Для того, чтобы избежать потери контекста, можно использовать:
// bind() - создание новой функции с фиксированным контекстом
// call()/apply() - вызов функции с явным указанием контекста

// setTimeout(person.sayHello.bind(person), 100)
// стрелочные функции - функции, не имеющие своего this
// наследуют контекст окружения где они находятся

const someFunc = (a, b) => {
  return `${a} и ${b}`
}
// const someFunc = (a, b) => `${a} и ${b}`

// Если аргументов нет, скобки должны присутствовать

const someFunc2 = () => {
  // ваш код
}

// Замыкания - создание функции, запоминающей свое окружение
// Инкремент без замыкания

let count = 0

function increment() {
  count++
  return count
  // return ++count
}

console.log(increment()) // 1, все работает
count = 10
console.log(increment()) // 11, результат не тот, что нам нужен

// С замыканием

function createIncrementClosure() {  // создание замыкания
  let counter = 0  // объявляем переменную в области видимости функции

  return function () {  // возвращаем новую функцию, запомнившую свое окружение, в т.ч. и counter
    return ++counter
  }
}

let incrementClosure = createIncrementClosure()
console.log(incrementClosure()) // 1
// console.log(counter) // ошибка, counter не объявлен
